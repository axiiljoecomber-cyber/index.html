<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Auto Motion Recording Webcam</title>
<style>
  :root {
    --bg: #0b1220;
    --muted: #9aa4b2;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: #fff;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  /* Main camera card */
  .card {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 16px auto;
    background: rgba(255,255,255,0.05);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 6px 24px rgba(0,0,0,0.6);
    display: grid;
    gap: 10px;
  }

  .square {
    width: 100%;
    aspect-ratio: 1/1; /* square */
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    resize: both;
    min-width: 200px;
    min-height: 200px;
    max-width: 95vw;
    max-height: 95vw;
  }
  video, canvas {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
  }
  canvas { pointer-events: none; }

  .status {
    font-size: 12px;
    color: var(--muted);
    margin-top: 4px;
    text-align: right;
  }

  /* Auto record toggle button */
  #autoToggleBtn {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 20;
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 6px;
    cursor: pointer;
  }

  #autoStatus {
    position: absolute;
    top: 8px;
    left: 8px;
    z-index: 20;
    font-size: 14px;
    font-weight: bold;
  }

  /* Draggable video boxes */
  .draggableBox {
    position: fixed;
    width: 320px;
    height: 180px;
    background: #000;
    border: 2px solid white;
    border-radius: 8px;
    resize: both;
    overflow: hidden;
    z-index: 10;
    display: flex;
    flex-direction: column;
    cursor: move;
  }
  .draggableBox video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .closeBtn {
    position: absolute;
    top: 2px;
    right: 4px;
    background: rgba(255,255,255,0.2);
    color: white;
    border: none;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 6px;
    border-radius: 4px;
    z-index: 11;
  }

  /* Bottom scrollable thumbnails */
  #recordingsContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    max-height: 140px;
    background: rgba(0,0,0,0.5);
    display: flex;
    overflow-x: auto;
    padding: 8px;
    gap: 8px;
    box-sizing: border-box;
  }
  .recording {
    flex-shrink: 0;
    width: 160px;
    height: 90px;
    position: relative;
    cursor: pointer;
    border-radius: 6px;
    overflow: hidden;
    background: #111;
  }
  .recording img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
  .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    background: rgba(0,0,0,0.6);
    clip-path: polygon(20% 15%, 20% 85%, 80% 50%);
    border-radius: 4px;
  }
</style>
</head>
<body>
  <div class="card">
    <div class="square" id="webcamContainer">
      <video id="webcamVideo" autoplay playsinline muted></video>
      <canvas id="motionCanvas"></canvas>
      <button id="autoToggleBtn">Turn Off Auto Record</button>
      <div id="autoStatus">Auto Recording On</div>
    </div>
    <div class="status" id="statusText">No camera active</div>
  </div>

  <!-- Bottom scrollable thumbnails -->
  <div id="recordingsContainer"></div>

<script>
const videoEl = document.getElementById("webcamVideo");
const canvasEl = document.getElementById("motionCanvas");
const ctx = canvasEl.getContext("2d");
const statusText = document.getElementById("statusText");
const recordingsContainer = document.getElementById("recordingsContainer");

const autoToggleBtn = document.getElementById("autoToggleBtn");
const autoStatus = document.getElementById("autoStatus");

let currentStream = null;
let recorder = null;
let recordedChunks = [];
let isRecording = false;
let lastFrame = null;
let noMotionTimeout = null;
let autoRecordEnabled = true;

// Track vertical stacking for new video boxes
let nextTop = 16;

autoToggleBtn.addEventListener("click", () => {
  autoRecordEnabled = !autoRecordEnabled;
  updateAutoUI();
});

function updateAutoUI() {
  if(autoRecordEnabled){
    autoToggleBtn.textContent = "Turn Off Auto Record";
    autoStatus.textContent = "Auto Recording On";
  } else {
    autoToggleBtn.textContent = "Turn On Auto Recording";
    autoStatus.textContent = "Auto Recording Off";
  }
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    currentStream = stream;
    videoEl.srcObject = stream;
    statusText.textContent = "Camera running (motion detection active)";
    requestAnimationFrame(detectMotion);
  } catch (err) {
    console.error(err);
    statusText.textContent = "Camera error: " + err.message;
  }
}

function startRecording() {
  if (!currentStream || isRecording || !autoRecordEnabled) return;
  recordedChunks = [];
  recorder = new MediaRecorder(currentStream, { mimeType: "video/webm; codecs=vp9" });
  recorder.ondataavailable = e => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };
  recorder.onstop = saveRecording;
  recorder.start();
  isRecording = true;
  statusText.textContent = "Recording (motion detected)";
}

function stopRecording() {
  if (recorder && isRecording) {
    recorder.stop();
    isRecording = false;
    statusText.textContent = autoRecordEnabled ? "Camera running (no motion)" : "Camera running (auto record off)";
  }
}

const recordedBlobs = [];

function saveRecording() {
  const blob = new Blob(recordedChunks, { type: "video/webm" });
  recordedBlobs.push(blob); // store blob to allow reopening

  // thumbnail
  const thumbCanvas = document.createElement("canvas");
  thumbCanvas.width = 160;
  thumbCanvas.height = 90;
  const thumbCtx = thumbCanvas.getContext("2d");
  thumbCtx.drawImage(videoEl, 0, 0, thumbCanvas.width, thumbCanvas.height);
  const thumbUrl = thumbCanvas.toDataURL("image/png");

  // create thumbnail element
  const container = document.createElement("div");
  container.className = "recording";

  const img = document.createElement("img");
  img.src = thumbUrl;
  const playBtn = document.createElement("div");
  playBtn.className = "play-button";

  container.appendChild(img);
  container.appendChild(playBtn);
  recordingsContainer.appendChild(container);

  // click thumbnail to create a new draggable video box
  container.addEventListener("click", () => {
    createDraggableVideo(blob); // pass blob directly
  });
}

function createDraggableVideo(blob) {
  const box = document.createElement("div");
  box.className = "draggableBox";

  // Limit vertical stacking to 3 videos
  const maxVertical = 3;
  const videoHeight = 200;
  const margin = 16;

  const existingVideos = document.querySelectorAll(".draggableBox").length;
  const row = existingVideos % maxVertical; // row in vertical stack
  const col = Math.floor(existingVideos / maxVertical); // horizontal offset

  box.style.top = margin + row * (videoHeight + 8) + "px";
  box.style.left = margin + col * (videoHeight + 8) + "px";

  const url = URL.createObjectURL(blob);

  const closeBtn = document.createElement("button");
  closeBtn.className = "closeBtn";
  closeBtn.textContent = "Ã—";
  closeBtn.onclick = () => {
    const vid = box.querySelector("video");
    vid.pause();
    vid.src = "";
    vid.load();
    box.remove();
    URL.revokeObjectURL(url);
  };
  box.appendChild(closeBtn);

  const vid = document.createElement("video");
  vid.src = url;
  vid.controls = true;
  vid.autoplay = true;
  vid.muted = false;
  vid.loop = false;

  vid.addEventListener('error', () => { vid.load(); vid.play().catch(()=>{}); });

  box.appendChild(vid);
  document.body.appendChild(box);

  makeDraggable(box);
}



function makeDraggable(el) {
  let offsetX, offsetY, isDragging = false;

  el.addEventListener("mousedown", (e) => {
    if(e.target.classList.contains('closeBtn')) return; // don't drag on close button
    isDragging = true;
    offsetX = e.clientX - el.getBoundingClientRect().left;
    offsetY = e.clientY - el.getBoundingClientRect().top;
    el.style.zIndex = 1000; // bring to front
  });

  document.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    el.style.left = (e.clientX - offsetX) + "px";
    el.style.top = (e.clientY - offsetY) + "px";
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });
}

function detectMotion() {
  if (!videoEl.videoWidth) {
    requestAnimationFrame(detectMotion);
    return;
  }
  canvasEl.width = videoEl.videoWidth;
  canvasEl.height = videoEl.videoHeight;

  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = videoEl.videoWidth;
  tempCanvas.height = videoEl.videoHeight;
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.drawImage(videoEl, 0, 0);
  const currentFrame = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

  ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

  if (lastFrame) {
    let diff = 0;
    let xMin = tempCanvas.width, yMin = tempCanvas.height, xMax = 0, yMax = 0;

    for (let i = 0; i < currentFrame.data.length; i += 4 * 8) {
      const delta = Math.abs(currentFrame.data[i] - lastFrame.data[i]) +
                    Math.abs(currentFrame.data[i+1] - lastFrame.data[i+1]) +
                    Math.abs(currentFrame.data[i+2] - lastFrame.data[i+2]);
      if (delta > 60) {
        const pixelIndex = i / 4;
        const x = pixelIndex % tempCanvas.width;
        const y = Math.floor(pixelIndex / tempCanvas.width);
        if (x < xMin) xMin = x;
        if (y < yMin) yMin = y;
        if (x > xMax) xMax = x;
        if (y > yMax) yMax = y;
        diff++;
      }
    }

    if (diff > 500 && autoRecordEnabled) {
      ctx.strokeStyle = "white";
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 2;
      ctx.strokeRect(xMin, yMin, xMax - xMin, yMax - yMin);
      ctx.setLineDash([]);

      startRecording();
      clearTimeout(noMotionTimeout);
      noMotionTimeout = setTimeout(stopRecording, 2000);
    }
  }

  lastFrame = currentFrame;
  requestAnimationFrame(detectMotion);
}

updateAutoUI();
startCamera();
</script>
</body>
</html>
