<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Auto Motion Recording Webcam - Axiil Security</title>
<style>
  :root {
    --bg: #0b1220;
    --muted: #9aa4b2;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: #fff;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  /* Main camera card */
  .card {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 16px auto;
    background: rgba(255,255,255,0.05);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 6px 24px rgba(0,0,0,0.6);
    display: grid;
    gap: 10px;
  }

  .square {
    width: 100%;
    aspect-ratio: 1/1; /* square */
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    resize: both;
    min-width: 200px;
    min-height: 200px;
    max-width: 95vw;
    max-height: 95vw;
  }
  video, canvas {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
  }
  canvas { pointer-events: none; }

  .status {
    font-size: 12px;
    color: var(--muted);
    margin-top: 4px;
    text-align: right;
  }

  /* Auto record toggle button */
  #autoToggleBtn {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 20;
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 6px;
    cursor: pointer;
  }

  #autoStatus {
    position: absolute;
    top: 8px;
    left: 8px;
    z-index: 20;
    font-size: 14px;
    font-weight: bold;
  }

  /* Draggable video boxes */
  .draggableBox {
    position: fixed;
    width: 320px;
    height: 180px;
    background: #000;
    border: 2px solid white;
    border-radius: 8px;
    resize: both;
    overflow: hidden;
    z-index: 10;
    display: flex;
    flex-direction: column;
    cursor: move;
  }
  .draggableBox video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .closeBtn {
    position: absolute;
    top: 2px;
    right: 4px;
    background: rgba(255,255,255,0.2);
    color: white;
    border: none;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 6px;
    border-radius: 4px;
    z-index: 11;
  }

  /* Bottom scrollable thumbnails */
  #recordingsContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    max-height: 140px;
    background: rgba(0,0,0,0.5);
    display: flex;
    overflow-x: auto;
    padding: 8px;
    gap: 8px;
    box-sizing: border-box;
  }
  .recording {
    flex-shrink: 0;
    width: 160px;
    height: 90px;
    position: relative;
    cursor: pointer;
    border-radius: 6px;
    overflow: hidden;
    background: #111;
  }
  .recording img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
  .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    background: rgba(0,0,0,0.6);
    clip-path: polygon(20% 15%, 20% 85%, 80% 50%);
    border-radius: 4px;
  }
 </style>

  <style>
    .brandHeader {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      line-height: 1;
      user-select: none;
    }
    .brandTitle {
      font-size: 28px;
      font-weight: bold;
      color: white;
      font-family: system-ui, sans-serif;
    }
    .brandSubtitle {
      font-size: 16px;
      color: white;
      font-family: system-ui, sans-serif;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="brandHeader">
    <div class="brandTitle">Axiil</div>
    <div class="brandSubtitle">Security</div>
  </div>
  <div class="card">
    <div class="square" id="webcamContainer">
      <video id="webcamVideo" autoplay playsinline muted></video>
      <canvas id="motionCanvas"></canvas>
      <button id="autoToggleBtn">Turn Off Auto Record</button>
      <div id="autoStatus">Auto Recording On</div>
    </div>
    <div class="status" id="statusText">No camera active</div>
  </div>

  <!-- Bottom scrollable thumbnails -->
  <div id="recordingsContainer"></div>

<script>
const videoEl = document.getElementById("webcamVideo");
const canvasEl = document.getElementById("motionCanvas");
const ctx = canvasEl.getContext("2d");
const statusText = document.getElementById("statusText");
const recordingsContainer = document.getElementById("recordingsContainer");

const autoToggleBtn = document.getElementById("autoToggleBtn");
const autoStatus = document.getElementById("autoStatus");

let currentStream = null;
let recorder = null;
let recordedChunks = [];
let isRecording = false;
let lastFrame = null;
let noMotionTimeout = null;
let autoRecordEnabled = true;

// Track vertical stacking for new video boxes
let nextTop = 16;

autoToggleBtn.addEventListener("click", () => {
  autoRecordEnabled = !autoRecordEnabled;
  updateAutoUI();
});

function updateAutoUI() {
  if(autoRecordEnabled){
    autoToggleBtn.textContent = "Turn Off Auto Record";
    autoStatus.textContent = "Auto Recording On";
  } else {
    autoToggleBtn.textContent = "Turn On Auto Recording";
    autoStatus.textContent = "Auto Recording Off";
  }
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    currentStream = stream;
    videoEl.srcObject = stream;
    statusText.textContent = "Camera running (motion detection active)";
    requestAnimationFrame(detectMotion);
  } catch (err) {
    console.error(err);
    statusText.textContent = "Camera error: " + err.message;
  }
}

function startRecording() {
  if (!currentStream || isRecording || !autoRecordEnabled) return;
  recordedChunks = [];

  // Create offscreen canvas for recording
  const recordCanvas = document.createElement("canvas");
  recordCanvas.width = videoEl.videoWidth || 640;
  recordCanvas.height = videoEl.videoHeight || 480;
  const recordCtx = recordCanvas.getContext("2d");

  function drawFrame() {
  if (!isRecording) return;

  // Clear previous frame
  recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);

  // Draw live video frame
  recordCtx.drawImage(videoEl, 0, 0, recordCanvas.width, recordCanvas.height);

  // Add timestamp overlay
  const timestamp = new Date().toLocaleString();
  recordCtx.fillStyle = "rgba(0,0,0,0.6)";
  const textWidth = recordCtx.measureText(timestamp).width + 10;
  recordCtx.fillRect(8, recordCanvas.height - 28, textWidth, 24);
  recordCtx.fillStyle = "white";
  recordCtx.font = "16px monospace";
  recordCtx.fillText(timestamp, 12, recordCanvas.height - 10);

  requestAnimationFrame(drawFrame);
}

requestAnimationFrame(drawFrame);

  // Use canvas stream + add mic audio
  const canvasStream = recordCanvas.captureStream(30);
  const audioTrack = currentStream.getAudioTracks()[0];
  if (audioTrack) canvasStream.addTrack(audioTrack);

  recorder = new MediaRecorder(canvasStream, { mimeType: "video/webm; codecs=vp9" });
  recorder.ondataavailable = e => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };
  recorder.onstop = saveRecording;
  recorder.start();
  isRecording = true;
  statusText.textContent = "Recording (motion detected)";
}


function stopRecording() {
  if (recorder && isRecording) {
    recorder.stop();
    isRecording = false;
    statusText.textContent = autoRecordEnabled ? "Camera running (no motion)" : "Camera running (auto record off)";
  }
}

const recordedBlobs = [];

// --- Auto-download flag (default OFF) and dynamic toggle button ---
// Put these near the top of your script or keep here before saveRecording is used
let autoDownload = false;

// create a button next to the auto record button so you don't have to edit HTML
// --- Auto record & auto download buttons setup ---
autoRecordEnabled = true;  // Auto Record ON by default
autoDownload = false;      // Auto Download OFF by default

updateAutoUI(); // Update auto record button text

(function createAutoDownloadButton() {
  const webcamContainer = document.getElementById("webcamContainer");
  if (!webcamContainer) return;

  const downloadBtn = document.createElement("button");
  downloadBtn.id = "autoDownloadBtn";
  downloadBtn.textContent = "Auto-Download OFF"; // default OFF

  Object.assign(downloadBtn.style, {
    position: "absolute",
    top: "40px", // slightly below auto record
    right: "8px",
    zIndex: 20,
    background: "rgba(255,255,255,0.2)",
    border: "none",
    color: "white",
    fontSize: "12px",
    padding: "4px 8px",
    borderRadius: "6px",
    cursor: "pointer",
  });

  downloadBtn.addEventListener("click", () => {
    autoDownload = !autoDownload;
    downloadBtn.textContent = autoDownload ? "Auto-Download ON" : "Auto-Download OFF";
    downloadBtn.style.background = autoDownload ? "rgba(0,150,0,0.3)" : "rgba(255,255,255,0.2)";
  });

  webcamContainer.appendChild(downloadBtn);
})();


// helper to download blob with a safe timestamped filename
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(url);
    a.remove();
  }, 1000);
}

// helper to format filename-safe timestamp
function filenameTimestamp(d) {
  const pad = (n) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
}

// --- New saveRecording() with optional auto-download ---
function saveRecording() {
  // Create recording blob and store it
  const blob = new Blob(recordedChunks, { type: "video/webm" });
  recordedBlobs.push(blob);

  // If auto-download is enabled, download immediately with timestamped filename
  if (autoDownload) {
    const now = new Date();
    const fname = `recording_${filenameTimestamp(now)}.webm`;
    try {
      downloadBlob(blob, fname);
    } catch (err) {
      console.warn("auto-download failed", err);
    }
  }

  // unique id for linking thumbnail <-> log entry
  const rid = "rec" + Date.now() + Math.floor(Math.random() * 1000);

  // --- Create thumbnail image ---
  const thumbCanvas = document.createElement("canvas");
  thumbCanvas.width = 160;
  thumbCanvas.height = 90;
  const thumbCtx = thumbCanvas.getContext("2d");
  try {
    thumbCtx.drawImage(videoEl, 0, 0, thumbCanvas.width, thumbCanvas.height);
  } catch (err) {
    console.warn("thumb draw failed", err);
  }
  const thumbUrl = thumbCanvas.toDataURL("image/png");

  // --- Container for thumbnail + label ---
  const container = document.createElement("div");
  container.className = "recording";
  container.dataset.rid = rid;
  Object.assign(container.style, {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    width: "160px",
    height: "110px",
    boxSizing: "border-box",
    padding: "4px 4px 6px 4px",
    background: "#111",
    borderRadius: "6px",
    overflow: "hidden",
  });

  // label above thumbnail
  const initialIndex = document.querySelectorAll(".recording").length + 1;
  const label = document.createElement("div");
  label.className = "recLabel";
  label.textContent = `Video ${initialIndex}`;
  Object.assign(label.style, {
    width: "100%",
    textAlign: "center",
    fontSize: "12px",
    color: "var(--muted)",
    marginBottom: "4px",
    userSelect: "none",
  });
  container.appendChild(label);

  // image
  const img = document.createElement("img");
  img.src = thumbUrl;
  Object.assign(img.style, {
    width: "100%",
    height: "90px",
    objectFit: "cover",
    display: "block",
    borderRadius: "4px"
  });
  container.appendChild(img);

  // center play icon
  const playBtn = document.createElement("div");
  playBtn.className = "play-button";
  playBtn.style.position = "absolute";
  playBtn.style.top = "50%";
  playBtn.style.left = "50%";
  playBtn.style.transform = "translate(-50%, -50%)";
  container.appendChild(playBtn);

  // delete button
  const delBtn = document.createElement("button");
  delBtn.className = "closeBtn";
  delBtn.style.top = "6px";
  delBtn.style.right = "6px";
  delBtn.style.fontSize = "12px";
  delBtn.textContent = "×";
  container.appendChild(delBtn);

  recordingsContainer.appendChild(container);

  // --- Right-side log box (create if missing) ---
  let logBox = document.getElementById("recordLog");
  if (!logBox) {
    logBox = document.createElement("div");
    logBox.id = "recordLog";
    Object.assign(logBox.style, {
      position: "fixed",
      top: "16px",
      right: "16px",
      width: "240px",
      maxHeight: "calc(100vh - 32px)",
      overflowY: "auto",
      background: "rgba(0,0,0,0.6)",
      color: "white",
      padding: "8px",
      borderRadius: "8px",
      zIndex: 9999,
      boxShadow: "0 6px 20px rgba(0,0,0,0.5)",
      fontSize: "13px",
      lineHeight: "1.3",
    });
    const title = document.createElement("div");
    title.textContent = "Record Log";
    title.style.fontWeight = "700";
    title.style.marginBottom = "6px";
    logBox.appendChild(title);
    document.body.appendChild(logBox);
  }

  // --- Log entry ---
  const timeStr = new Date().toLocaleTimeString([], { hour: "numeric", minute: "2-digit", hour12: true });
  const logItem = document.createElement("div");
  logItem.className = "logItem";
  logItem.dataset.rid = rid;
  logItem.dataset.time = timeStr;
  logItem.textContent = `Video ${initialIndex}: ${timeStr}`;
  Object.assign(logItem.style, {
    padding: "6px 6px",
    borderTop: "1px solid rgba(255,255,255,0.06)",
    cursor: "pointer",
    userSelect: "none"
  });
  logBox.appendChild(logItem);

  // --- Click handlers ---
  logItem.addEventListener("click", () => createDraggableVideo(blob));
  container.addEventListener("click", (e) => {
    if (e.target === delBtn) return;
    createDraggableVideo(blob);
  });

  // --- Delete handler: remove both thumbnail and log entry, then renumber ---
  delBtn.onclick = (e) => {
    e.stopPropagation();
    container.remove();
    logItem.remove();
    updateLabels();
  };

  function updateLabels() {
    const containers = Array.from(document.querySelectorAll(".recording"));
    containers.forEach((c, i) => {
      const lab = c.querySelector(".recLabel");
      if (lab) lab.textContent = `Video ${i + 1}`;
      const rid = c.dataset.rid;
      const log = document.querySelector(`#recordLog .logItem[data-rid="${rid}"]`);
      if (log) {
        log.textContent = `Video ${i + 1}: ${log.dataset.time}`;
      }
    });
  }

  updateLabels();
}




function createDraggableVideo(blob) {
  const box = document.createElement("div");
  box.className = "draggableBox";

  // Limit vertical stacking to 3 videos
  const maxVertical = 3;
  const videoHeight = 200;
  const margin = 16;

  const existingVideos = document.querySelectorAll(".draggableBox").length;
  const row = existingVideos % maxVertical; // row in vertical stack
  const col = Math.floor(existingVideos / maxVertical); // horizontal offset

  box.style.top = margin + row * (videoHeight + 8) + "px";
  box.style.left = margin + col * (videoHeight + 8) + "px";

  const url = URL.createObjectURL(blob);

  const closeBtn = document.createElement("button");
  closeBtn.className = "closeBtn";
  closeBtn.textContent = "×";
  closeBtn.onclick = () => {
    const vid = box.querySelector("video");
    vid.pause();
    vid.src = "";
    vid.load();
    box.remove();
    URL.revokeObjectURL(url);
  };
  box.appendChild(closeBtn);

  const vid = document.createElement("video");
  vid.src = url;
  vid.controls = true;
  vid.autoplay = true;
  vid.muted = false;
  vid.loop = false;

  vid.addEventListener('error', () => { vid.load(); vid.play().catch(()=>{}); });

  box.appendChild(vid);
  document.body.appendChild(box);

  makeDraggable(box);
}



function makeDraggable(el) {
  let offsetX, offsetY, isDragging = false;

  el.addEventListener("mousedown", (e) => {
    if(e.target.classList.contains('closeBtn')) return; // don't drag on close button
    isDragging = true;
    offsetX = e.clientX - el.getBoundingClientRect().left;
    offsetY = e.clientY - el.getBoundingClientRect().top;
    el.style.zIndex = 1000; // bring to front
  });

  document.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    el.style.left = (e.clientX - offsetX) + "px";
    el.style.top = (e.clientY - offsetY) + "px";
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });
}

function detectMotion() {
  if (!videoEl.videoWidth) {
    requestAnimationFrame(detectMotion);
    return;
  }
  canvasEl.width = videoEl.videoWidth;
  canvasEl.height = videoEl.videoHeight;

  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = videoEl.videoWidth;
  tempCanvas.height = videoEl.videoHeight;
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.drawImage(videoEl, 0, 0);
  const currentFrame = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

  ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

  if (lastFrame) {
    let diff = 0;
    let xMin = tempCanvas.width, yMin = tempCanvas.height, xMax = 0, yMax = 0;

    for (let i = 0; i < currentFrame.data.length; i += 4 * 8) {
      const delta = Math.abs(currentFrame.data[i] - lastFrame.data[i]) +
                    Math.abs(currentFrame.data[i+1] - lastFrame.data[i+1]) +
                    Math.abs(currentFrame.data[i+2] - lastFrame.data[i+2]);
      if (delta > 60) {
        const pixelIndex = i / 4;
        const x = pixelIndex % tempCanvas.width;
        const y = Math.floor(pixelIndex / tempCanvas.width);
        if (x < xMin) xMin = x;
        if (y < yMin) yMin = y;
        if (x > xMax) xMax = x;
        if (y > yMax) yMax = y;
        diff++;
      }
    }

    if (diff > 500 && autoRecordEnabled) {
      ctx.strokeStyle = "white";
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 2;
      ctx.strokeRect(xMin, yMin, xMax - xMin, yMax - yMin);
      ctx.setLineDash([]);

      startRecording();
      clearTimeout(noMotionTimeout);
      noMotionTimeout = setTimeout(stopRecording, 2000);
    }
  }

  lastFrame = currentFrame;
  requestAnimationFrame(detectMotion);
}

updateAutoUI();
startCamera();
</script>
</body>
</html>
